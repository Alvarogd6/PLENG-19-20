/* Generated By:JavaCC: Do not edit this line. MiniLengCompiler.java */
import lib.Tabla_estadisticas;
import lib.Tabla_simbolos;
import lib.GenerarCodigo;
import lib.RegistroExpr;
import lib.RegistroExpr.Tipo_operador;
import lib.Simbolo;
import lib.Simbolo.Tipo_variable;
import lib.Simbolo.Clase_parametro;
import lib.exceptions.ModuloDeCeroException;
import lib.exceptions.FicheroNoEscribibleException;
import lib.exceptions.DesbordamientoEnterosException;
import lib.exceptions.DivisionPorCeroException;
import lib.exceptions.TiposDiferentesException;
import lib.exceptions.SimboloNoEncontradoException;
import lib.exceptions.SimboloExistenteException;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.File;
import java.util.LinkedList;
import java.util.Iterator;

public class MiniLengCompiler implements MiniLengCompilerConstants {
  public static final long init = 3;
  public static boolean panic = false;
  public static boolean asig = false;
  public static boolean show = false;
  public static long dir = init;
  public static int level = 0;
  public static Tabla_simbolos table = new Tabla_simbolos();
  public static GenerarCodigo gen;

  public static int totalSemantico = 0;
  public static int totalSintactico = 0;

  public static void error_skipto(int kind) {
    Token t;
    do {
      t = getNextToken();
    } while (t.kind != kind && t.kind != EOF);
  }

  public static void panic_mode(ParseException e, int kind) {
    System.out.println("PANIC MODE: Falta un ; en <"
      + SimpleCharStream.getBeginLine() + ", " + SimpleCharStream.getBeginColumn() + ">");
  }

  public static void errorLexico() {
    System.out.println("ERROR L\u00c9XICO (<" + SimpleCharStream.getBeginLine()
          + ", " + SimpleCharStream.getBeginColumn() + ">): S\u00edmbolo no reconocido: <"
          + SimpleCharStream.GetImage().substring(0, 1) + ">");
  }

  public static void errorSemantico(String s) {
    ++totalSemantico;
        System.out.println("ERROR SEMANTICO (<" + SimpleCharStream.getBeginLine()
          + ", " + SimpleCharStream.getBeginColumn() + ">): < " + s + " >");
  }

  public static void errorSintactico(ParseException e) {
    ++totalSintactico;
        System.out.println("ERROR SINT\u00c1CTICO (<" + SimpleCharStream.getBeginLine()
          + ", " + SimpleCharStream.getBeginColumn() + ">): < S\u00edmbolo encontrado incorrecto: "
          + SimpleCharStream.GetImage() + " >");
        error_skipto(tPCOMA);
  }

  public static void addVariable(Token id, Tipo_variable tipo) {
        try {
          if(id != null) {
            table.introducir_variable(id.image, tipo, level, dir);
                ++dir;
          }
        }
        catch(SimboloExistenteException e) {
          errorSemantico("Identificador " + id.image + " duplicado");
        }
  }

  public static void addVector(Token id, Tipo_variable tipo, Token tam) {
    if(tam != null) {
      int aux = Integer.parseInt(tam.image);
          try {
            if(id != null) {
              table.introducir_vector(id.image, tipo, aux, level, dir);
              gen.escribir("; Tamano del vector " + id.image + ".");
              gen.escribir("\u005ct SRF 0 " + dir);
              gen.escribir("\u005ct STC " + aux);
              gen.escribir("\u005ct ASG");
                  dir += aux + 1;
            }
          }
          catch(SimboloExistenteException e) {
            errorSemantico("Identificador " + id.image + " duplicado");
          }
          if(aux == 0) {
            errorSemantico("Vector " + id.image + " definido sin tamano");
          }
        }
  }

  public static boolean checkParametro(Simbolo s, int i, RegistroExpr reg, boolean ex) {
        LinkedList<Simbolo> list = s.getLista_parametros();
    if(list != null) {
      if(list.size() <= i) {
        if(!ex) errorSemantico("Exceso de parametros en la llamada a la accion " + s.getNombre());
        return true;
      }
      Simbolo aux = list.get(i);
      Tipo_variable tp = reg.getTipo();
      Clase_parametro cl = reg.getClase();
      if(aux.getVariable() != tp && tp != Tipo_variable.DESCONOCIDO && !aux.es_desconocido()) {
        errorSemantico("Argumento de tipo " + tp + " no valido (se esperaba " + aux.getVariable() + ")");
      }
      if(cl == Clase_parametro.VAL && aux.es_referencia()) {
        errorSemantico("Argumento de tipo VAL introducido en parametro de tipo REF");
      }
      if(ex) return true;
    }
    return false;
  }

  public static void posVector(Simbolo s, RegistroExpr ind) {
    if(s != null) {
      gen.escribir("; Direcci\u00f3n de la variable " + s.getNombre().toUpperCase() + "[" + ind.getValor() + "].");
      gen.escribir("\u005ct SRF " + (level - s.getNivel(ind.getValor())) + " " + s.getDir(ind.getValor()));
      if(s.es_parametro() && s.es_referencia()) {
        gen.escribir("\u005ct DRF");
      }
    }
  }

  public static void checkTam(Simbolo s, RegistroExpr ind) {
    String etMAL = gen.nueva_etiqueta(), etBIEN = gen.nueva_etiqueta();
    gen.escribir("; Comprobar si la posicion existe.");
    gen.escribir("\u005ct GTE");
    gen.escribir("; Si el nivel es mayor que la posicion, continua");
    gen.escribir("\u005ct JMF " + etMAL);

    gen.escribir("\u005ct STC " + ind.getValor());
    gen.escribir("\u005ct STC 0");
    gen.escribir("\u005ct LT");
    gen.escribir("; Si la posicion es mayor que 0, es correcta");
    gen.escribir("\u005ct JMF " + etBIEN);
    gen.escribir(etMAL + ":");
    gen.escribir("; ERROR: Posicion fuera de rango");
    etMAL = "ERROR: Posicion fuera de rango";
    for(int i = 0; i < etMAL.length(); ++i) {
          gen.escribir("\u005ct STC " + (int)etMAL.charAt(i));
          gen.escribir("\u005ct WRT 0");
        }

    gen.escribir(etBIEN + ":");
    gen.escribir("; Posicion valida del vector");
  }

  public static void main(String args []) throws Exception
  {
    boolean v = false;
    String nameFile = "";
    if(args.length == 0) {
      System.out.println("Sintaxis: java minilengcompiler [argumentos] <fichero_sin_extension>");
      System.out.println("Posibles argumentos:");
      System.out.println(" -v: Muestra una tabla con las apariciones de cada simbolo del programa");
      System.out.println(" -t: Muestra una tabla con las apariciones de cada simbolo despu\u00e9s de cada acci\u00f3n");
      System.out.println(" -p: Panic mode (si falta un ;, no se cuenta como error)");
          return;
    }
    for(int i = 0; i < args.length; ++i) {
      switch(args[i]) {
                case "-v":
                        v = true;
                        break;
                case "-p":
                        panic = true;
                        break;
                case "-t":
                        show = true;
                        break;
                default:
                        if(args[i].charAt(0) == '-') {
                                for(int j = 1; j < args[i].length(); ++j) {
                                        switch(args[i].charAt(j)) {
                                          case 'v':
                                                v = true;
                                                break;
                                          case 'p':
                                                panic = true;
                                                break;
                                          case 't':
                                                show = true;
                                                break;
                                          default:
                                        }
                                }
                        } else {
                                nameFile = args[i];
                        }
          }
    }
    if(nameFile.equals("")) {
      throw new java.io.FileNotFoundException("Fichero no introducido");
    }
    gen = new GenerarCodigo(nameFile);
    Tabla_estadisticas estTabla = new Tabla_estadisticas();

    try {
      File initialFile = new File(nameFile + ".ml");
          InputStream targetStream = new FileInputStream(initialFile);
          MiniLengCompiler parser = new MiniLengCompiler(targetStream);
        } catch(java.io.FileNotFoundException e) {
          System.out.println(e);
          return;
        }
          try {
                MiniLengCompiler.programa();
                if(v) {
                  System.out.println("\u005cnEstad\u00edsticas totales\u005cn");
                  Tabla_estadisticas.estadisticas();
                }
                if(totalSemantico == 0 && totalSintactico == 0) {
                  try {
                    gen.completar();
                  }
                  catch(FicheroNoEscribibleException e) {
                    System.out.println("No se ha podido generar el fichero .code correspondiente");
                  }
                } else {
                  System.out.println();
                  if(totalSintactico > 0) {
                    System.out.println("Se han detectado un total de " + totalSintactico + " errores sintacticos");
                  }
                  if(totalSemantico > 0) {
                    System.out.println("Se han detectado un total de " + totalSemantico + " errores semanticos");
                  }
                }
          }
          catch (Exception e) {
                System.out.println("NOK.");
            System.out.println(e.getMessage());
            e.printStackTrace();
          }
          catch (Error e) {
            errorLexico();
          }
  }

  static final public void punto_y_coma() throws ParseException {
    try {
      jj_consume_token(tPCOMA);
    } catch (ParseException e) {
    if(panic) panic_mode(e, tPCOMA);
    else errorSintactico(e);
    }
  }

  static final public Token valid_id() throws ParseException {
  Token t = null;
    try {
      t = jj_consume_token(tIDENTIFICADOR);
    } catch (ParseException e) {
    errorSintactico(e);
    }
    {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  static final public void programa() throws ParseException {
  Token id = null;
  String et;
    try {
      jj_consume_token(tPROGRAMA);
      id = valid_id();
          if(id.image != null) {
                table.introducir_programa(id.image, null);
                gen.escribir("; Programa " + id.image.toUpperCase() + ".");
          }
          et = gen.nueva_etiqueta();
          gen.escribir("\u005ct ENP  " + et);
      punto_y_coma();
      declaracion_variables();
      declaracion_acciones();
          if(id.image != null) {
            gen.escribir("; Comienzo del programa " + id.image.toUpperCase() + ".");
          }
          gen.escribir(et + ":");
      bloque_sentencias(null);
    } catch (ParseException e) {
        errorSintactico(e);
    }
    if(id.image != null) {
          gen.escribir("; Fin del programa " + id.image.toUpperCase() + ".");
        }
        gen.escribir("\u005ct LVP");

        table.eliminar_variables(level);
        table.eliminar_acciones(level);
        table.eliminar_programa();
  }

  static final public void declaracion_variables() throws ParseException {
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tENTERO:
        case tBOOLEANO:
        case tCARACTER:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        declaracion();
        punto_y_coma();
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
  }

  static final public void declaracion() throws ParseException {
  Tipo_variable tipo;
    try {
      tipo = tipo_variables();
      identificadores(tipo);
    } catch (ParseException e) {
        errorSintactico(e);
    }
  }

  static final public Tipo_variable tipo_variables() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tENTERO:
        jj_consume_token(tENTERO);
                        {if (true) return Tipo_variable.ENTERO;}
        break;
      case tBOOLEANO:
        jj_consume_token(tBOOLEANO);
                          {if (true) return Tipo_variable.BOOLEANO;}
        break;
      case tCARACTER:
        jj_consume_token(tCARACTER);
                          {if (true) return Tipo_variable.CHAR;}
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  static final public void identificadores(Tipo_variable tipo) throws ParseException {
  Token id, indice = null;
    try {
      id = valid_id();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tCOR_IZQ:
        jj_consume_token(tCOR_IZQ);
        indice = jj_consume_token(tCONSTENTERA);
        jj_consume_token(tCOR_DCHA);
        break;
      default:
        jj_la1[2] = jj_gen;
        ;
      }
          if(indice == null) {
            addVariable(id, tipo);
          } else {
            addVector(id, tipo, indice);
            indice = null;
          }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tCOMA:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_2;
        }
        jj_consume_token(tCOMA);
        id = valid_id();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tCOR_IZQ:
          jj_consume_token(tCOR_IZQ);
          indice = jj_consume_token(tCONSTENTERA);
          jj_consume_token(tCOR_DCHA);
          break;
        default:
          jj_la1[4] = jj_gen;
          ;
        }
            if(indice == null) {
              addVariable(id, tipo);
            } else {
              addVector(id, tipo, indice);
              indice = null;
            }
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
  }

  static final public void declaracion_acciones() throws ParseException {
    try {
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tACCION:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_3;
        }
        declaracion_accion();
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
  }

  static final public void declaracion_accion() throws ParseException {
  Simbolo id = null;
  String et = "";
  long aux = dir, actual = gen.getNum();
  dir = init;
    try {
      id = cabecera_accion();
          if(actual != gen.getNum()) {
            et = "L" + gen.getNum();
          } else {
            et = gen.nueva_etiqueta();
          }
      punto_y_coma();
      declaracion_variables();
      declaracion_acciones();
          if(id != null) {
            gen.escribir(et + ":");
            gen.escribir("; Comienzo de la acci\u00f3n " + id.getNombre().toUpperCase() + ".");
          }
      bloque_sentencias(id);
          table.eliminar_variables(level);
          table.eliminar_acciones(level);
          table.ocultar_parametros(level);
          level--;
          if(id != null) {
            gen.escribir("; Fin de la acci\u00f3n / funci\u00f3n " + id.getNombre().toUpperCase() + ".");
          }
          gen.escribir("\u005ct CSF");
    } catch (ParseException e) {
        errorSintactico(e);
    }
    dir = aux;
  }

  static final public Simbolo cabecera_accion() throws ParseException {
  Token id = null;
  Simbolo s = null;
  boolean ok = false;
  LinkedList<Simbolo> list = new LinkedList<Simbolo>();
    try {
      jj_consume_token(tACCION);
      id = valid_id();
          if(id != null) {
            try {
              s = table.introducir_accion(id.image, level, gen.getNum() + 1);
              ok = true;
              gen.escribir("; Acci\u00f3n " + id.image.toUpperCase() + ".");
            }
            catch(SimboloExistenteException e) {
              errorSemantico("Identificador " + id.image + " duplicado");
              ok = false;
            }
            level++;
          }
      list = parametros_formales();
          if(ok) {
            s.setLista_parametros(list);
          }
          if(list != null && list.size() != 0) {
            gen.escribir(gen.nueva_etiqueta() + ":");
            Iterator<Simbolo> itr = list.descendingIterator();
            if(itr.hasNext() && s != null) {
              gen.escribir("; Par\u00e1metros de la acci\u00f3n " + s.getNombre() + ".");
            }
            while(itr.hasNext()) {
              s = itr.next();
              gen.escribir("\u005ct SRF " + (level - s.getNivel()) + " " + s.getDir());
              gen.escribir("\u005ct ASGI");
            }
            gen.escribir("\u005ct JMP " + gen.nueva_etiqueta());
          }
    } catch (ParseException e) {
        errorSintactico(e);
    }
    {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  static final public LinkedList<Simbolo> parametros_formales() throws ParseException {
  LinkedList<Simbolo> list = new LinkedList<Simbolo>(), aux;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tPAREN_IZQ:
        jj_consume_token(tPAREN_IZQ);
        list = parametros();
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case tPCOMA:
            ;
            break;
          default:
            jj_la1[6] = jj_gen;
            break label_4;
          }
          punto_y_coma();
          aux = parametros();
          list.addAll(aux);
        }
        jj_consume_token(tPAREN_DCHA);
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
    {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  static final public LinkedList<Simbolo> lista_parametros(Clase_parametro clase, Tipo_variable tipo) throws ParseException {
  Token id;
  LinkedList<Simbolo> list = new LinkedList<Simbolo>();
  Simbolo s;
    try {
      id = valid_id();
      if(id != null) {
        try {
                  s = table.introducir_parametro(id.image, tipo, clase, level, dir);
                  ++dir;
                  list.add(s);
        }
        catch(SimboloExistenteException e) {
          errorSemantico("Identificador " + id.image + " duplicado");
        }
      }
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tCOMA:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_5;
        }
        jj_consume_token(tCOMA);
        id = valid_id();
            if(id != null) {
          try {
                    s = table.introducir_parametro(id.image, tipo, clase, level, dir);
                    ++dir;
                list.add(s);
          }
          catch(SimboloExistenteException e) {
            errorSemantico("Identificador " + id.image + " duplicado");
          }

        }
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
    {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  static final public LinkedList<Simbolo> parametros() throws ParseException {
  Tipo_variable tipo;
  Clase_parametro clase;
  LinkedList<Simbolo> list = new LinkedList<Simbolo>();
    try {
      clase = clase_parametros();
      tipo = tipo_variables();
      list = lista_parametros(clase, tipo);
    } catch (ParseException e) {
        errorSintactico(e);
    }
    {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  static final public Clase_parametro clase_parametros() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tVAL:
        jj_consume_token(tVAL);
                   {if (true) return Clase_parametro.VAL;}
        break;
      case tREF:
        jj_consume_token(tREF);
               {if (true) return Clase_parametro.REF;}
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  static final public void bloque_sentencias(Simbolo s) throws ParseException {
    try {
      jj_consume_token(tPRINCIPIO);
      lista_sentencias();
      jj_consume_token(tFIN);
          if(show && s != null) {
                System.out.println("\u005cn " + s.getNombre() + ": Estad\u00edsticas\u005cn");
                Tabla_estadisticas.estadisticas();
          }
    } catch (ParseException e) {
        errorSintactico(e);
    }
  }

  static final public void lista_sentencias() throws ParseException {
    try {
      label_6:
      while (true) {
        sentencia();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tSI:
        case tMQ:
        case tESCRIBIR:
        case tLEER:
        case tIDENTIFICADOR:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_6;
        }
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
  }

  static final public void sentencia() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tLEER:
        leer();
        punto_y_coma();
        break;
      case tESCRIBIR:
        escribir();
        punto_y_coma();
        break;
      case tIDENTIFICADOR:
        asig_acc();
        break;
      case tSI:
        seleccion();
        break;
      case tMQ:
        mientras_que();
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
  }

  static final public void asig_acc() throws ParseException {
  Token t;
  Simbolo s = null;
  Tipo_variable tpExpr;
    try {
      t = valid_id();
          try {
            s = table.buscar_simbolo(t.image);
            tpExpr = s.getVariable();
          }
          catch(SimboloNoEncontradoException e) {
            errorSemantico("Identificador " + t.image + " no encontrado");
            tpExpr = Tipo_variable.DESCONOCIDO;
            try {
          s = table.introducir_variable(t.image, Tipo_variable.DESCONOCIDO, level, dir);
          ++dir;
        }
        catch(SimboloExistenteException not) { }
          }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tOPAS:
      case tCOR_IZQ:
        asignacion(s, tpExpr);
        break;
      default:
        jj_la1[12] = jj_gen;
        invocacion_accion(s);
          if(!s.es_accion() && !s.es_desconocido()) {
            errorSemantico("Invocacion a accion " + s.getNombre() + " no encontrada");
          }
      }
      punto_y_coma();
    } catch (ParseException e) {
        errorSintactico(e);
    }
  }

  static final public void leer() throws ParseException {
    try {
      jj_consume_token(tLEER);
      jj_consume_token(tPAREN_IZQ);
      lista_asignables();
      jj_consume_token(tPAREN_DCHA);
    } catch (ParseException e) {
        errorSintactico(e);
    }
  }

  static final public void lista_asignables() throws ParseException {
  Token id;
  Simbolo s;
    try {
      id = valid_id();
      if(id != null) {
        try {
          s = table.buscar_simbolo(id.image);
          if(!s.es_leible()) {
            errorSemantico("Variable " + id.image + " no leible");
          } else {
            gen.escribir("; Leer.");
            gen.escribir("\u005ct SRF " + (level - s.getNivel()) + " " + s.getDir());
            if(s.es_parametro() && s.es_referencia()) {
              gen.escribir("\u005ct DRF");
            }
            if(s.es_caracter()) {
              gen.escribir("\u005ct RD 0");
            } else {
              gen.escribir("\u005ct RD 1");
            }
          }
        }
        catch(SimboloNoEncontradoException e) {
          errorSemantico("Identificador " + id.image + " no encontrado");
          try {
            s = table.introducir_variable(id.image, Tipo_variable.DESCONOCIDO, level, dir);
            ++dir;
          }
          catch(SimboloExistenteException not) { }
        }
      }
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tCOMA:
          ;
          break;
        default:
          jj_la1[13] = jj_gen;
          break label_7;
        }
        jj_consume_token(tCOMA);
        id = valid_id();
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
  }

  static final public void escribir() throws ParseException {
    try {
      jj_consume_token(tESCRIBIR);
      jj_consume_token(tPAREN_IZQ);
      lista_escribibles();
      jj_consume_token(tPAREN_DCHA);
    } catch (ParseException e) {
        errorSintactico(e);
    }
  }

  static final public void lista_escribibles() throws ParseException {
  gen.escribir("; Escribir.");
    try {
      escribibles();
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tCOMA:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_8;
        }
        jj_consume_token(tCOMA);
        escribibles();
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
  }

  static final public void escribibles() throws ParseException {
  RegistroExpr regExpr;
  Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tCONSTCAD:
        t = jj_consume_token(tCONSTCAD);
            if(t != null) {
              gen.escribir("; cadena '" + t.image.substring(1, t.image.length() - 1) + "'.");
              for(int i = 1; i < t.image.length() - 1; ++i) {
                gen.escribir("\u005ct STC " + (int)t.image.charAt(i));
                gen.escribir("\u005ct WRT 0");
              }
            }
        break;
      case tENTACAR:
      case tCARAENT:
      case tNOT:
      case tTRUE:
      case tFALSE:
      case tPAREN_IZQ:
      case tRESTA:
      case tCONSTCHAR:
      case tIDENTIFICADOR:
      case tCONSTENTERA:
        regExpr = expresion(true);
          if(regExpr.getTipo() == Tipo_variable.ENTERO) {
            gen.escribir("\u005ct WRT 1");
          } else if(regExpr.getTipo() == Tipo_variable.CHAR) {
            gen.escribir("\u005ct WRT 0");
          } else if(regExpr.getTipo() == Tipo_variable.BOOLEANO) {
            gen.escribir("; Comprobar si es true o false.");
            gen.escribir("\u005ct STC 1");
            gen.operador(Tipo_operador.IGUAL);

            String et = gen.nueva_etiqueta();
            gen.escribir("; Si es false salta.");
            gen.escribir("\u005ct JMF " + et);

            gen.escribir("; Escribir cadena 'Verdadero'");
            String aux = "Verdadero";
            for(int i = 0; i < aux.length(); ++i) {
              gen.escribir("\u005ct STC " + (int)aux.charAt(i));
              gen.escribir("\u005ct WRT 0");
            }

            String et2 = gen.nueva_etiqueta();
            gen.escribir("\u005ct JMP " + et2);

            gen.escribir(et + ":");

            gen.escribir("; Escribir cadena 'Falso'");
            aux = "Falso";
            for(int i = 0; i < aux.length(); ++i) {
              gen.escribir("\u005ct STC " + (int)aux.charAt(i));
              gen.escribir("\u005ct WRT 0");
            }

            gen.escribir("; Fin comprobar si es true o false.");
            gen.escribir(et2 + ":");
          }
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
  }

  static final public void asignacion(Simbolo s, Tipo_variable tpExpr) throws ParseException {
  RegistroExpr regExpr, indice = null;

  if(s != null) {
    gen.escribir("; Direcci\u00f3n de la variable " + s.getNombre().toUpperCase() + ".");
    gen.escribir("\u005ct SRF " + (level - s.getNivel()) + " " + s.getDir());
    if(s.es_parametro() && s.es_referencia()) {
      gen.escribir("\u005ct DRF");
    }
  }
  asig = true;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tCOR_IZQ:
        jj_consume_token(tCOR_IZQ);
        indice = expresion(false);
        jj_consume_token(tCOR_DCHA);
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      jj_consume_token(tOPAS);
          asig = false;
          if(s.es_parametro() && s.es_valor()) {
            errorSemantico("No se puede realizar una asignacion a un parametro por valor");
          }
          if(indice != null && indice.getTipo() != Tipo_variable.DESCONOCIDO) {
            if(s.getTam() == null) {
              errorSemantico("Variable " + s.getNombre() + " no es un vector");
            } else if(indice.getTipo() != Tipo_variable.ENTERO) {
              errorSemantico("Indice del vector " + s.getNombre() + " de tipo diferente a entero");
            } else if(indice.getValor() != null) {
              if(indice.getValor() >= s.getTam()) {
                errorSemantico("Desbordamiento de overflow del vector " + s.getNombre());
              } else if(indice.getValor() < 0) {
                errorSemantico("Desbordamiento de underflow del vector " + s.getNombre());
              } else {
                checkTam(s, indice);
                posVector(s, indice);
              }
            }
          }
      regExpr = expresion(true);
          try {
            regExpr.operacionOk(tpExpr);
          }
          catch(TiposDiferentesException e) {
            errorSemantico("Tipos incompatibles en la asignacion (" + tpExpr + ", " + regExpr.getTipo() + ")");
          }
          gen.escribir("; Asignaci\u00f3n.");
          gen.escribir("\u005ct ASG");
    } catch (ParseException e) {
        errorSintactico(e);
    }
  }

  static final public void invocacion_accion(Simbolo s) throws ParseException {
  if(s != null) {
    gen.escribir("; Invocaci\u00f3n a " + s.getNombre().toUpperCase() + ".");
  }
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tPAREN_IZQ:
        argumentos(s);
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
    if(s != null) {
      gen.escribir("\u005ct OSF " + (dir - 1) + " " + (level - s.getNivel()) + " L" + s.getDir());
    }
  }

  static final public void mientras_que() throws ParseException {
  RegistroExpr regExpr;
  String etMQ = gen.nueva_etiqueta(), etFMQ = "";
  gen.escribir(etMQ + ":");
  gen.escribir("; MQ.");
    try {
      jj_consume_token(tMQ);
      regExpr = expresion(true);
          if(regExpr != null && regExpr.getTipo() != Tipo_variable.DESCONOCIDO && regExpr.getTipo() != Tipo_variable.BOOLEANO) {
                errorSemantico("La condicion del bucle debe ser un booleano");
          }
          etFMQ = gen.nueva_etiqueta();
          gen.escribir("; Salir del bucle si la guarda se eval\u00faa a falso.");
          gen.escribir("\u005ct JMF " + etFMQ);
      lista_sentencias();
      jj_consume_token(tFMQ);
    } catch (ParseException e) {
        errorSintactico(e);
    }
    gen.escribir("; Fin de la iteraci\u00f3n. Saltar a la cabecera del bucle.");
    gen.escribir("\u005ct JMP " + etMQ);
    gen.escribir(etFMQ + ":");
    gen.escribir("; Fin MQ.");
  }

  static final public void seleccion() throws ParseException {
  RegistroExpr regExpr;
  String et = gen.nueva_etiqueta();

  gen.escribir("; SI.");
    try {
      jj_consume_token(tSI);
      regExpr = expresion(true);
          if(regExpr.getTipo() != Tipo_variable.DESCONOCIDO && regExpr.getTipo() != Tipo_variable.BOOLEANO) {
                errorSemantico("La condicion de la seleccion debe ser un booleano");
          }
          gen.escribir("\u005ct JMF " + et);
          gen.escribir("; ENT.");
      jj_consume_token(tENT);
      lista_sentencias();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tSI_NO:
        jj_consume_token(tSI_NO);
             String fin = gen.nueva_etiqueta();
             gen.escribir("\u005ct JMP " + fin);
             gen.escribir(et + ":");
             gen.escribir("; SI_NO.");
             et = fin;
        lista_sentencias();
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      jj_consume_token(tFSI);
    } catch (ParseException e) {
        errorSintactico(e);
    }
    gen.escribir(et + ":");
    gen.escribir("; Fin SI.");
  }

  static final public void argumentos(Simbolo s) throws ParseException {
    try {
      jj_consume_token(tPAREN_IZQ);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tENTACAR:
      case tCARAENT:
      case tNOT:
      case tTRUE:
      case tFALSE:
      case tPAREN_IZQ:
      case tRESTA:
      case tCONSTCHAR:
      case tIDENTIFICADOR:
      case tCONSTENTERA:
        lista_expresiones(s);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      jj_consume_token(tPAREN_DCHA);
    } catch (ParseException e) {
        errorSintactico(e);
    }
  }

  static final public void lista_expresiones(Simbolo s) throws ParseException {
  int i = 0;
  boolean exceso = false, drf = true;
  RegistroExpr regExpr;

  if(s.getLista_parametros() != null && i < s.getLista_parametros().size() && s.getLista_parametros().get(i).es_referencia()) {
    drf = false;
  }
    try {
      regExpr = expresion(drf);
      exceso = checkParametro(s, i, regExpr, exceso);
      ++i;
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tCOMA:
          ;
          break;
        default:
          jj_la1[20] = jj_gen;
          break label_9;
        }
        jj_consume_token(tCOMA);
        if(s.getLista_parametros() != null && i < s.getLista_parametros().size() && s.getLista_parametros().get(i).es_referencia()) {
          drf = false;
        } else {
          drf = true;
        }
        regExpr = expresion(drf);
        exceso = checkParametro(s, i, regExpr, exceso);
        ++i;
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
    if(s.getLista_parametros() != null && i < s.getLista_parametros().size()) {
      errorSemantico("Faltan argumentos en la llamada a la accion " + s.getNombre());
    }
  }

  static final public RegistroExpr expresion(boolean val) throws ParseException {
 RegistroExpr tpExpr1 = new RegistroExpr(), tpExpr2;
 Tipo_operador t;
    try {
      tpExpr1 = expresion_simple(val);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tNI:
      case tMAI:
      case tMEI:
      case tMAYOR:
      case tMENOR:
      case tIGUAL:
        t = operador_relacional();
        tpExpr2 = expresion_simple(val);
        try {
          tpExpr1.operacion(tpExpr2, t);
        }
        catch(TiposDiferentesException e) {
          errorSemantico("Los tipos " + tpExpr1.getTipo() + " y " + tpExpr2.getTipo() + " no concuerdan");
        }
        catch(DivisionPorCeroException e) {
          errorSemantico("Detectada division entre 0");
        }
        catch(ModuloDeCeroException e) {
          errorSemantico("Detectado modulo de 0");
        }
        catch(DesbordamientoEnterosException e) {
              errorSemantico("Detectado desbordamiento de enteros");
            }
            gen.operador(t);
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
    {if (true) return tpExpr1;}
    throw new Error("Missing return statement in function");
  }

  static final public Tipo_operador operador_relacional() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tNI:
        jj_consume_token(tNI);
              {if (true) return Tipo_operador.NI;}
        break;
      case tMAI:
        jj_consume_token(tMAI);
                 {if (true) return Tipo_operador.MAI;}
        break;
      case tMEI:
        jj_consume_token(tMEI);
                 {if (true) return Tipo_operador.MEI;}
        break;
      case tMAYOR:
        jj_consume_token(tMAYOR);
                   {if (true) return Tipo_operador.MAYOR;}
        break;
      case tMENOR:
        jj_consume_token(tMENOR);
                   {if (true) return Tipo_operador.MENOR;}
        break;
      case tIGUAL:
        jj_consume_token(tIGUAL);
                   {if (true) return Tipo_operador.IGUAL;}
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  static final public RegistroExpr expresion_simple(boolean val) throws ParseException {
  RegistroExpr regTerm1 = new RegistroExpr(), regTerm2;
  Tipo_operador op;
    try {
      regTerm1 = termino(val);
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tOR:
        case tSUMA:
        case tRESTA:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_10;
        }
        op = operador_aditivo();
        regTerm2 = termino(val);
        try {
          regTerm1.operacion(regTerm2, op);
        }
        catch(TiposDiferentesException e) {
          errorSemantico("Los tipos " + regTerm1.getTipo() + " y " + regTerm2.getTipo() + " no concuerdan");
        }
        catch(DivisionPorCeroException e) {
          errorSemantico("Detectada division entre 0");
        }
        catch(ModuloDeCeroException e) {
          errorSemantico("Detectado modulo de 0");
        }
        catch(DesbordamientoEnterosException e) {
              errorSemantico("Detectado desbordamiento de enteros");
            }
            gen.operador(op);
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
    {if (true) return regTerm1;}
    throw new Error("Missing return statement in function");
  }

  static final public Tipo_operador operador_aditivo() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tSUMA:
        jj_consume_token(tSUMA);
                {if (true) return Tipo_operador.SUMA;}
        break;
      case tRESTA:
        jj_consume_token(tRESTA);
                   {if (true) return Tipo_operador.RESTA;}
        break;
      case tOR:
        jj_consume_token(tOR);
                {if (true) return Tipo_operador.OR;}
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  static final public RegistroExpr termino(boolean val) throws ParseException {
  RegistroExpr regFac1 = new RegistroExpr(), regFac2;
  Tipo_operador op;
    try {
      regFac1 = factor(val);
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tAND:
        case tMUL:
        case tDIV:
        case tMOD:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_11;
        }
        op = operador_multiplicativo();
        regFac2 = factor(val);
        try {
          regFac1.operacion(regFac2, op);
        }
        catch(TiposDiferentesException e) {
          errorSemantico("Los tipos " + regFac1.getTipo() + " y " + regFac2.getTipo() + " no concuerdan");
        }
        catch(DivisionPorCeroException e) {
          errorSemantico("Detectada division entre 0");
        }
        catch(ModuloDeCeroException e) {
          errorSemantico("Detectado modulo de 0");
        }
        catch(DesbordamientoEnterosException e) {
              errorSemantico("Detectado desbordamiento de enteros");
            }
            gen.operador(op);
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
    {if (true) return regFac1;}
    throw new Error("Missing return statement in function");
  }

  static final public Tipo_operador operador_multiplicativo() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tDIV:
        jj_consume_token(tDIV);
               {if (true) return Tipo_operador.DIV;}
        break;
      case tMUL:
        jj_consume_token(tMUL);
                 {if (true) return Tipo_operador.MUL;}
        break;
      case tMOD:
        jj_consume_token(tMOD);
                 {if (true) return Tipo_operador.MOD;}
        break;
      case tAND:
        jj_consume_token(tAND);
                 {if (true) return Tipo_operador.AND;}
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
    {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  static final public RegistroExpr factor(boolean val) throws ParseException {
  RegistroExpr result = new RegistroExpr(), indice = null;
  Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tRESTA:
        jj_consume_token(tRESTA);
        result = factor(val);
          if(result.getTipo() != Tipo_variable.ENTERO && result.getTipo() != Tipo_variable.DESCONOCIDO) {
            errorSemantico("Tipo incompatible. Se esperaba entero y se ha obtenido " + result.getTipo());
          } else if(result.getValor() != null) {
            result.setValor(result.getValor() * (-1));
          }
          gen.escribir("\u005ct NGI");
        break;
      case tNOT:
        jj_consume_token(tNOT);
        result = factor(val);
          if(result.getTipo() != Tipo_variable.BOOLEANO && result.getTipo() != Tipo_variable.DESCONOCIDO) {
            errorSemantico("Tipo incompatible. Se esperaba booleano y se ha obtenido " + result.getTipo());
          } else if(result.isBool() != null) {
            result.setBool(!result.isBool());
          }
          gen.escribir("\u005ct NGB");
        break;
      case tPAREN_IZQ:
        jj_consume_token(tPAREN_IZQ);
        result = expresion(val);
        jj_consume_token(tPAREN_DCHA);
        break;
      case tENTACAR:
        jj_consume_token(tENTACAR);
        jj_consume_token(tPAREN_IZQ);
        result = expresion(val);
        jj_consume_token(tPAREN_DCHA);
          Character c = null;
          if(result.getTipo() != Tipo_variable.ENTERO && result.getTipo() != Tipo_variable.DESCONOCIDO) {
            errorSemantico("La expresion no se puede convertir en un caracter valido");
          } else if(result.getValor() != null) {
            if(result.getValor() < 0 || result.getValor() > 255) {
              errorSemantico("Detectado desbordamiento ASCII");
            } else {
              c = (char)result.getValor().intValue();
            }
          }
          result = new RegistroExpr();
          result.setTipo(Tipo_variable.CHAR);
          if(c != null) {
            result.setCar(c);
          }
        break;
      case tCARAENT:
        jj_consume_token(tCARAENT);
        jj_consume_token(tPAREN_IZQ);
        result = expresion(val);
        jj_consume_token(tPAREN_DCHA);
          Integer i = null;
          if(result.getTipo() != Tipo_variable.CHAR && result.getTipo() != Tipo_variable.DESCONOCIDO) {
            errorSemantico("La expresion no se puede convertir en un entero valido");
          } else if(result.getCar() != null) {
            i = (int)result.getCar().charValue();
          }
          result = new RegistroExpr();
          result.setTipo(Tipo_variable.ENTERO);
          if(i != null) {
            result.setValor(i);
          }
        break;
      case tIDENTIFICADOR:
        t = valid_id();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tCOR_IZQ:
          jj_consume_token(tCOR_IZQ);
          Simbolo s = null;
          try {
            s = table.buscar_simbolo(t.image);
          }
          catch(SimboloNoEncontradoException e) { }
          if(!asig && s != null) {
        gen.escribir("; Direcci\u00f3n de la variable " + s.getNombre().toUpperCase() + ".");
        gen.escribir("\u005ct SRF " + (level - s.getNivel()) + " " + s.getDir());
        if(s.es_parametro() && s.es_referencia()) {
          gen.escribir("\u005ct DRF");
        }
      }
      asig = false;
          indice = expresion(val);
          jj_consume_token(tCOR_DCHA);
          break;
        default:
          jj_la1[27] = jj_gen;
          ;
        }
          Simbolo s = null;
          try {
            s = table.buscar_simbolo(t.image);
            if(indice == null) {
              result = new RegistroExpr(s);
            } else if(indice.getTipo() != Tipo_variable.ENTERO && indice.getTipo() != Tipo_variable.DESCONOCIDO) {
              errorSemantico("Posicion del vector " + s.getNombre() + " no es de tipo entero");
              result = new RegistroExpr(s);
            } else if(indice.getTipo() != Tipo_variable.DESCONOCIDO && indice.getValor() != null) {
              if(indice.getValor() >= s.getTam()) {
                errorSemantico("Desbordamiento de overflow del vector " + s.getNombre());
                result = new RegistroExpr(s);
              } else if(indice.getValor() < 0) {
                errorSemantico("Desbordamiento de underflow del vector " + s.getNombre());
                result = new RegistroExpr(s);
              } else {
                checkTam(s, indice);
                result = new RegistroExpr(s.getNum(indice.getValor()));
              }
            }
          }
          catch(SimboloNoEncontradoException e) {
            errorSemantico("Identificador " + t.image + " no encontrado");
            try {
              if(indice == null) {
                s = table.introducir_variable(t.image, Tipo_variable.DESCONOCIDO, level, dir);
                ++dir;
                result = new RegistroExpr(s);
              } else if(indice.getTipo() != Tipo_variable.ENTERO) {
                s = table.introducir_vector(t.image, Tipo_variable.DESCONOCIDO, 0, level, dir);
                ++dir;
                result = new RegistroExpr(s);
              } else {
                s = table.introducir_vector(t.image, Tipo_variable.DESCONOCIDO, indice.getValor(), level, dir);
                dir += indice.getValor();
                result = new RegistroExpr(s.getNum(indice.getValor()));
              }
            }
            catch(SimboloExistenteException not) { }
          }

          if(s != null && !s.es_desconocido()) {
            gen.escribir("; Acceso a la variable " + s.getNombre().toUpperCase() + ".");
            if(indice == null) {
              gen.escribir("\u005ct SRF " + (level - s.getNivel()) + " " + s.getDir());
            } else if(indice.getTipo() == Tipo_variable.ENTERO && indice.getValor() != null) {
              posVector(s, indice);
            }
            if(s.es_parametro() && s.es_referencia()) {
              gen.escribir("\u005ct DRF");
            }
            if(val) {
              gen.escribir("\u005ct DRF");
            }
          }
        break;
      case tCONSTENTERA:
        t = jj_consume_token(tCONSTENTERA);
          result = new RegistroExpr();
          try {
            result.setValor(Long.parseLong(t.image));
          }
          catch(DesbordamientoEnterosException e) {
            errorSemantico("Detectado desbordamiento de enteros");
          }
          result.setTipo(Tipo_variable.ENTERO);
          if(result.getValor() != null) {
            gen.escribir("\u005ct STC " + result.getValor());
          }
        break;
      case tCONSTCHAR:
        t = jj_consume_token(tCONSTCHAR);
          result = new RegistroExpr();
          result.setCar(t.image.charAt(1));
          result.setTipo(Tipo_variable.CHAR);
          gen.escribir("\u005ct STC " + (int)t.image.charAt(1));
        break;
      case tTRUE:
        jj_consume_token(tTRUE);
          result = new RegistroExpr();
          result.setBool(true);
          result.setTipo(Tipo_variable.BOOLEANO);
          gen.escribir("\u005ct STC 1");
        break;
      case tFALSE:
        jj_consume_token(tFALSE);
          result = new RegistroExpr();
          result.setBool(false);
          result.setTipo(Tipo_variable.BOOLEANO);
          gen.escribir("\u005ct STC 0");
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        errorSintactico(e);
    }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public MiniLengCompilerTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[29];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x68000000,0x68000000,0x0,0x400000,0x0,0x100000,0x200000,0x0,0x400000,0x80000000,0x6044000,0x6044000,0x0,0x400000,0x400000,0x1800000,0x0,0x0,0x10000,0x1800000,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1800000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x100000,0x0,0x100000,0x0,0x0,0x2000,0x0,0x1,0x8000000,0x8000000,0x180000,0x0,0x0,0x1e00ac80,0x100000,0x2000,0x0,0x1a00ac80,0x0,0x7e,0x7e,0xc200,0xc200,0x70100,0x70100,0x100000,0x1a00ac80,};
   }

  /** Constructor with InputStream. */
  public MiniLengCompiler(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public MiniLengCompiler(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new MiniLengCompilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public MiniLengCompiler(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new MiniLengCompilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public MiniLengCompiler(MiniLengCompilerTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(MiniLengCompilerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[61];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 29; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 61; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
